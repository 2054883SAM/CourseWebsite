{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Database Schema Updates",
        "description": "Implement the required database schema changes to support subtitle tracking and processing status.",
        "details": "Execute SQL statements to alter the courses table and create the subtitle_processing table as specified in the PRD. This includes:\n1. Adding has_subtitles and subtitle_languages columns to the courses table\n2. Creating the subtitle_processing table with appropriate foreign key relationships\n3. Ensuring proper indexing for performance\n4. Adding timestamp fields for tracking\n\nSQL implementation:\n```sql\n-- Subtitle tracking in courses table\nALTER TABLE courses \nADD COLUMN has_subtitles BOOLEAN DEFAULT false,\nADD COLUMN subtitle_languages JSONB DEFAULT '{\"fr\": false, \"en\": false, \"es\": false}';\n\n-- Subtitle processing tracking table\nCREATE TABLE subtitle_processing (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  course_id UUID REFERENCES courses(id) NOT NULL,\n  video_id VARCHAR NOT NULL,\n  status VARCHAR NOT NULL,\n  progress JSONB DEFAULT '{\"fr\": \"pending\", \"en\": \"pending\", \"es\": \"pending\"}',\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()\n);\n\n-- Add index for faster lookups\nCREATE INDEX idx_subtitle_processing_course_video ON subtitle_processing(course_id, video_id);\n```",
        "testStrategy": "1. Write unit tests to verify schema changes using a test database\n2. Test CRUD operations on the new and modified tables\n3. Verify default values are correctly applied\n4. Test foreign key constraints with valid and invalid data\n5. Verify indexing improves query performance with EXPLAIN ANALYZE",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Supabase Storage Setup with RLS Policies",
        "description": "Create the 'translations' storage bucket in Supabase and implement Row Level Security policies for proper access control.",
        "details": "1. Create a new storage bucket named 'translations' in Supabase\n2. Enable Row Level Security on the storage.objects table\n3. Implement the three RLS policies as specified in the PRD:\n   - Admin full access policy\n   - Creator access policy for their own courses\n   - Student access policy for enrolled courses\n4. Set up the folder structure template for organizing subtitles by courseId and videoId\n\nImplementation:\n```sql\n-- Create translations bucket\nINSERT INTO storage.buckets (id, name) VALUES ('translations', 'translations');\n\n-- Enable RLS\nALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;\n\n-- Admins have full access\nCREATE POLICY \"Admins have full access to translations\"\nON storage.objects FOR ALL\nUSING (bucket_id = 'translations' AND auth.role() = 'admin');\n\n-- Creators can access their own course translations\nCREATE POLICY \"Creators can access their own course translations\"\nON storage.objects FOR SELECT\nUSING (\n  bucket_id = 'translations' AND\n  auth.role() = 'creator' AND\n  (storage.foldername(name))[1] IN (\n    SELECT id::text FROM courses WHERE creator_id = auth.uid()\n  )\n);\n\n-- Students can access translations for enrolled courses\nCREATE POLICY \"Students can access translations for enrolled courses\"\nON storage.objects FOR SELECT\nUSING (\n  bucket_id = 'translations' AND\n  auth.role() = 'student' AND\n  (storage.foldername(name))[1] IN (\n    SELECT course_id::text FROM enrollments WHERE user_id = auth.uid()\n  )\n);\n```",
        "testStrategy": "1. Test bucket creation and accessibility\n2. Verify RLS policies by attempting access with different user roles:\n   - Admin should have full CRUD access\n   - Creators should only access their own course subtitles\n   - Students should only access subtitles for courses they're enrolled in\n   - Unauthenticated users should have no access\n3. Test edge cases like deleted courses or unenrolled students",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Audio Extraction Service",
        "description": "Develop a service to extract audio from uploaded course videos for transcription processing.",
        "details": "Create a service that extracts audio from video files to prepare for Whisper API processing:\n\n1. Use FFmpeg for audio extraction with the following specifications:\n   - Extract audio in MP3 format at 128kbps\n   - Normalize audio levels for better transcription results\n   - Handle various video formats (MP4, MOV, AVI, etc.)\n\n2. Implementation approach:\n```javascript\nconst extractAudio = async (videoPath, outputPath) => {\n  try {\n    // Use child_process to execute FFmpeg command\n    const command = `ffmpeg -i ${videoPath} -vn -ar 44100 -ac 2 -b:a 128k ${outputPath}`;\n    await exec(command);\n    \n    // Verify the audio file was created successfully\n    const stats = await fs.stat(outputPath);\n    if (stats.size === 0) throw new Error('Audio extraction failed - empty file');\n    \n    return { success: true, path: outputPath };\n  } catch (error) {\n    console.error('Audio extraction failed:', error);\n    return { success: false, error: error.message };\n  }\n};\n```\n\n3. Create a queue system for processing multiple videos\n4. Implement error handling and retry logic\n5. Add logging for debugging and monitoring",
        "testStrategy": "1. Unit test the extraction function with various video formats\n2. Test with videos of different durations (short, medium, long)\n3. Test with videos containing different audio qualities\n4. Verify extracted audio quality is sufficient for transcription\n5. Test error handling with corrupted video files\n6. Performance testing with large video files",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Whisper API Integration for French Transcription",
        "description": "Implement integration with OpenAI's Whisper API to generate accurate French transcriptions from course videos.",
        "details": "Create a service to handle French transcription using Whisper API:\n\n1. Set up OpenAI API client with proper authentication\n2. Configure Whisper API parameters for optimal French transcription:\n   - Use 'whisper-1' model\n   - Set language parameter to 'fr'\n   - Enable timestamps\n\n3. Implementation approach:\n```javascript\nconst generateFrenchTranscription = async (audioFilePath, courseId, videoId) => {\n  try {\n    // Update processing status\n    await updateSubtitleStatus(courseId, videoId, 'processing', { fr: 'processing' });\n    \n    // Read audio file as a buffer\n    const audioBuffer = await fs.readFile(audioFilePath);\n    \n    // Call Whisper API\n    const response = await openai.audio.transcriptions.create({\n      file: audioBuffer,\n      model: 'whisper-1',\n      language: 'fr',\n      response_format: 'vtt',\n      timestamp_granularities: ['segment']\n    });\n    \n    // Save VTT content to Supabase storage\n    const vttPath = `translations/${courseId}/${videoId}/fr.vtt`;\n    await supabaseClient.storage.from('translations').upload(vttPath, response, {\n      contentType: 'text/vtt',\n      upsert: true\n    });\n    \n    // Update status\n    await updateSubtitleStatus(courseId, videoId, 'completed', { fr: 'completed' });\n    \n    return { success: true, vttPath };\n  } catch (error) {\n    console.error('French transcription failed:', error);\n    await updateSubtitleStatus(courseId, videoId, 'error', { fr: 'error' });\n    return { success: false, error: error.message };\n  }\n};\n```\n\n4. Implement rate limiting and retry logic for API failures\n5. Add monitoring for API usage and costs\n6. Create a function to convert Whisper response to properly formatted VTT",
        "testStrategy": "1. Unit test the transcription function with sample audio files\n2. Test with various French accents and speaking styles\n3. Verify VTT format compliance\n4. Test error handling and retry mechanisms\n5. Verify timestamp accuracy in generated subtitles\n6. Test with audio of varying quality and background noise\n7. Benchmark transcription accuracy against manual transcriptions",
        "priority": "high",
        "dependencies": [
          11,
          12,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "DeepL API Integration for Subtitle Translation",
        "description": "Implement integration with DeepL API to translate French subtitles to English and Spanish while preserving VTT formatting and timestamps.",
        "details": "Create a service to handle subtitle translation using DeepL API:\n\n1. Set up DeepL API client with proper authentication\n2. Develop VTT parsing and reconstruction logic to preserve timestamps\n3. Implement translation for both English and Spanish targets\n\n```javascript\nconst translateSubtitles = async (courseId, videoId, sourceLang = 'fr', targetLangs = ['en', 'es']) => {\n  try {\n    // Update processing status for target languages\n    const statusUpdate = targetLangs.reduce((acc, lang) => {\n      acc[lang] = 'processing';\n      return acc;\n    }, {});\n    await updateSubtitleStatus(courseId, videoId, 'processing', statusUpdate);\n    \n    // Get source VTT file\n    const { data: sourceVtt } = await supabaseClient.storage\n      .from('translations')\n      .download(`${courseId}/${videoId}/${sourceLang}.vtt`);\n    \n    const sourceText = await sourceVtt.text();\n    \n    // Parse VTT to separate timestamps from content\n    const parsedVtt = parseVtt(sourceText);\n    \n    // Process each target language\n    for (const targetLang of targetLangs) {\n      try {\n        // Only translate the content parts, not timestamps\n        const translatedContent = await Promise.all(\n          parsedVtt.cues.map(async (cue) => {\n            const translated = await deepl.translate({\n              text: cue.text,\n              source_lang: sourceLang.toUpperCase(),\n              target_lang: targetLang === 'en' ? 'EN-US' : 'ES'\n            });\n            return { ...cue, text: translated.text };\n          })\n        );\n        \n        // Reconstruct VTT with original timestamps and translated content\n        const translatedVtt = reconstructVtt({\n          header: parsedVtt.header,\n          cues: translatedContent\n        });\n        \n        // Save translated VTT\n        const vttPath = `translations/${courseId}/${videoId}/${targetLang}.vtt`;\n        await supabaseClient.storage.from('translations').upload(vttPath, translatedVtt, {\n          contentType: 'text/vtt',\n          upsert: true\n        });\n        \n        // Update status for this language\n        await updateSubtitleStatus(courseId, videoId, 'processing', { [targetLang]: 'completed' });\n      } catch (error) {\n        console.error(`Translation to ${targetLang} failed:`, error);\n        await updateSubtitleStatus(courseId, videoId, 'processing', { [targetLang]: 'error' });\n      }\n    }\n    \n    // Check if all translations are complete\n    const status = await getSubtitleStatus(courseId, videoId);\n    const allCompleted = Object.values(status.progress).every(s => s === 'completed');\n    if (allCompleted) {\n      await updateSubtitleStatus(courseId, videoId, 'completed');\n    }\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Translation process failed:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n// Helper functions for VTT parsing and reconstruction\nfunction parseVtt(vttContent) {\n  // Implementation to parse VTT format and separate timestamps from text\n}\n\nfunction reconstructVtt(parsedData) {\n  // Implementation to rebuild VTT with timestamps and translated text\n}\n```\n\n4. Implement rate limiting and quota management\n5. Add error handling and retry logic\n6. Create a background job system for processing translations asynchronously",
        "testStrategy": "1. Unit test VTT parsing and reconstruction functions\n2. Test translation quality for various content types\n3. Verify timestamp preservation in translated files\n4. Test with different language pairs\n5. Verify handling of special characters and formatting\n6. Test error handling and retry mechanisms\n7. Benchmark translation quality against human translations\n8. Test performance with large subtitle files",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "VdoCipher Integration for Subtitle Display",
        "description": "Implement integration with VdoCipher API to upload subtitles and associate them with video playback IDs.",
        "details": "Create a service to handle VdoCipher subtitle integration:\n\n1. Set up VdoCipher API client with proper authentication\n2. Implement subtitle upload and association with video IDs\n3. Configure subtitle display options in the video player\n\n```javascript\nconst uploadSubtitlesToVdoCipher = async (courseId, videoId, vdoCipherPlaybackId) => {\n  try {\n    // Update processing status\n    await updateSubtitleStatus(courseId, videoId, 'uploading_to_player');\n    \n    // Get all subtitle files for this video\n    const languages = ['fr', 'en', 'es'];\n    const subtitles = [];\n    \n    for (const lang of languages) {\n      try {\n        // Check if this language subtitle exists\n        const { data: subtitleFile } = await supabaseClient.storage\n          .from('translations')\n          .download(`${courseId}/${videoId}/${lang}.vtt`);\n        \n        if (subtitleFile) {\n          const subtitleContent = await subtitleFile.text();\n          \n          // Upload subtitle to VdoCipher\n          const response = await vdoCipherClient.post('/subtitle', {\n            videoId: vdoCipherPlaybackId,\n            language: lang,\n            label: lang === 'fr' ? 'Français' : lang === 'en' ? 'English' : 'Español',\n            content: subtitleContent,\n            default: lang === 'fr' // Set French as default\n          });\n          \n          subtitles.push({\n            language: lang,\n            subtitleId: response.data.subtitleId\n          });\n        }\n      } catch (error) {\n        console.error(`Error uploading ${lang} subtitle:`, error);\n      }\n    }\n    \n    // Update course metadata to indicate subtitles are available\n    const availableLanguages = subtitles.reduce((acc, sub) => {\n      acc[sub.language] = true;\n      return acc;\n    }, { fr: false, en: false, es: false });\n    \n    await supabaseClient\n      .from('courses')\n      .update({\n        has_subtitles: subtitles.length > 0,\n        subtitle_languages: availableLanguages\n      })\n      .eq('id', courseId);\n    \n    // Update subtitle processing status\n    await updateSubtitleStatus(courseId, videoId, 'completed');\n    \n    return { success: true, subtitles };\n  } catch (error) {\n    console.error('VdoCipher subtitle integration failed:', error);\n    await updateSubtitleStatus(courseId, videoId, 'error');\n    return { success: false, error: error.message };\n  }\n};\n```\n\n4. Implement configuration for subtitle display options:\n   - Default language selection\n   - Font size and style\n   - Position on screen\n5. Add error handling and retry logic\n6. Create functions to update or remove subtitles when needed",
        "testStrategy": "1. Test subtitle upload to VdoCipher with various file sizes\n2. Verify subtitle association with correct video IDs\n3. Test subtitle display in the VdoCipher player\n4. Verify language selection functionality\n5. Test subtitle synchronization with video content\n6. Test across different browsers and devices\n7. Verify error handling for failed uploads\n8. Test subtitle updates and removals",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          14,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "API Endpoints for Subtitle Generation and Status",
        "description": "Create API endpoints to trigger subtitle generation and check processing status.",
        "details": "Implement the following API endpoints:\n\n1. `/api/upload-video/generate-subtitles`: Triggers subtitle generation\n```javascript\n// API route handler for generating subtitles\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n  \n  try {\n    // Authenticate request\n    const { user } = await supabaseServerClient(req);\n    if (!user) return res.status(401).json({ error: 'Unauthorized' });\n    \n    // Validate request body\n    const { courseId, videoId, videoUrl } = req.body;\n    if (!courseId || !videoId || !videoUrl) {\n      return res.status(400).json({ error: 'Missing required fields' });\n    }\n    \n    // Check permissions (user must be course creator or admin)\n    const { data: course } = await supabaseClient\n      .from('courses')\n      .select('creator_id')\n      .eq('id', courseId)\n      .single();\n    \n    if (!course || (course.creator_id !== user.id && user.role !== 'admin')) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n    \n    // Create subtitle processing record\n    const { data: processingRecord, error } = await supabaseClient\n      .from('subtitle_processing')\n      .insert({\n        course_id: courseId,\n        video_id: videoId,\n        status: 'queued'\n      })\n      .single();\n    \n    if (error) throw error;\n    \n    // Add job to processing queue\n    await subtitleQueue.add('generate-subtitles', {\n      courseId,\n      videoId,\n      videoUrl,\n      userId: user.id\n    });\n    \n    return res.status(200).json({\n      success: true,\n      message: 'Subtitle generation queued',\n      processingId: processingRecord.id\n    });\n  } catch (error) {\n    console.error('Subtitle generation request failed:', error);\n    return res.status(500).json({ error: 'Failed to queue subtitle generation' });\n  }\n}\n```\n\n2. `/api/upload-video/subtitle-status`: Checks processing status\n```javascript\n// API route handler for checking subtitle status\nexport default async function handler(req, res) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n  \n  try {\n    // Authenticate request\n    const { user } = await supabaseServerClient(req);\n    if (!user) return res.status(401).json({ error: 'Unauthorized' });\n    \n    // Get query parameters\n    const { courseId, videoId } = req.query;\n    if (!courseId || !videoId) {\n      return res.status(400).json({ error: 'Missing required parameters' });\n    }\n    \n    // Check permissions based on user role\n    let hasAccess = false;\n    \n    if (user.role === 'admin') {\n      hasAccess = true;\n    } else if (user.role === 'creator') {\n      // Check if user is the course creator\n      const { data: course } = await supabaseClient\n        .from('courses')\n        .select('creator_id')\n        .eq('id', courseId)\n        .single();\n      \n      hasAccess = course && course.creator_id === user.id;\n    } else if (user.role === 'student') {\n      // Check if student is enrolled in the course\n      const { data: enrollment } = await supabaseClient\n        .from('enrollments')\n        .select('id')\n        .eq('course_id', courseId)\n        .eq('user_id', user.id)\n        .single();\n      \n      hasAccess = !!enrollment;\n    }\n    \n    if (!hasAccess) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n    \n    // Get subtitle processing status\n    const { data: processingStatus } = await supabaseClient\n      .from('subtitle_processing')\n      .select('*')\n      .eq('course_id', courseId)\n      .eq('video_id', videoId)\n      .order('created_at', { ascending: false })\n      .limit(1)\n      .single();\n    \n    if (!processingStatus) {\n      return res.status(404).json({ error: 'No subtitle processing found' });\n    }\n    \n    return res.status(200).json({\n      success: true,\n      status: processingStatus.status,\n      progress: processingStatus.progress,\n      updatedAt: processingStatus.updated_at\n    });\n  } catch (error) {\n    console.error('Subtitle status check failed:', error);\n    return res.status(500).json({ error: 'Failed to check subtitle status' });\n  }\n}\n```\n\n3. Implement authentication and authorization middleware\n4. Add request validation and error handling\n5. Implement rate limiting to prevent abuse\n6. Add logging for debugging and monitoring",
        "testStrategy": "1. Unit test API endpoints with mock requests\n2. Test authentication and authorization with different user roles\n3. Test input validation with valid and invalid data\n4. Test error handling for various scenarios\n5. Test rate limiting functionality\n6. Integration test with actual subtitle generation flow\n7. Load test endpoints with concurrent requests\n8. Test API documentation and OpenAPI spec compliance",
        "priority": "medium",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Background Processing Queue System",
        "description": "Implement a robust background processing queue for handling subtitle generation and translation tasks asynchronously.",
        "details": "Create a background processing system using Bull or a similar queue library:\n\n1. Set up Redis for queue storage\n2. Create separate queues for different processing stages\n3. Implement job processors for each stage\n\n```javascript\n// Queue setup\nconst Redis = require('ioredis');\nconst Bull = require('bull');\n\nconst redisConfig = {\n  host: process.env.REDIS_HOST,\n  port: process.env.REDIS_PORT,\n  password: process.env.REDIS_PASSWORD\n};\n\n// Create queues for different stages\nconst audioExtractionQueue = new Bull('audio-extraction', { redis: redisConfig });\nconst transcriptionQueue = new Bull('transcription', { redis: redisConfig });\nconst translationQueue = new Bull('translation', { redis: redisConfig });\nconst vdoCipherQueue = new Bull('vdocipher-upload', { redis: redisConfig });\n\n// Main subtitle generation queue that orchestrates the process\nconst subtitleQueue = new Bull('subtitle-generation', { redis: redisConfig });\n\n// Process jobs in the main queue\nsubtitleQueue.process('generate-subtitles', async (job) => {\n  const { courseId, videoId, videoUrl } = job.data;\n  \n  try {\n    // Update status to processing\n    await updateSubtitleStatus(courseId, videoId, 'processing');\n    \n    // Step 1: Extract audio\n    job.progress(10);\n    const audioJob = await audioExtractionQueue.add({\n      courseId,\n      videoId,\n      videoUrl\n    });\n    const audioResult = await audioJob.finished();\n    \n    if (!audioResult.success) {\n      throw new Error(`Audio extraction failed: ${audioResult.error}`);\n    }\n    \n    // Step 2: Generate French transcription\n    job.progress(30);\n    const transcriptionJob = await transcriptionQueue.add({\n      courseId,\n      videoId,\n      audioPath: audioResult.audioPath\n    });\n    const transcriptionResult = await transcriptionJob.finished();\n    \n    if (!transcriptionResult.success) {\n      throw new Error(`Transcription failed: ${transcriptionResult.error}`);\n    }\n    \n    // Step 3: Translate to other languages\n    job.progress(50);\n    const translationJob = await translationQueue.add({\n      courseId,\n      videoId,\n      sourceLang: 'fr',\n      targetLangs: ['en', 'es']\n    });\n    const translationResult = await translationJob.finished();\n    \n    if (!translationResult.success) {\n      throw new Error(`Translation failed: ${translationResult.error}`);\n    }\n    \n    // Step 4: Upload to VdoCipher\n    job.progress(80);\n    const vdoCipherJob = await vdoCipherQueue.add({\n      courseId,\n      videoId\n    });\n    const vdoCipherResult = await vdoCipherJob.finished();\n    \n    if (!vdoCipherResult.success) {\n      throw new Error(`VdoCipher upload failed: ${vdoCipherResult.error}`);\n    }\n    \n    // Update final status\n    await updateSubtitleStatus(courseId, videoId, 'completed');\n    \n    // Update course metadata\n    await supabaseClient\n      .from('courses')\n      .update({\n        has_subtitles: true,\n        subtitle_languages: vdoCipherResult.languages\n      })\n      .eq('id', courseId);\n    \n    job.progress(100);\n    return { success: true };\n  } catch (error) {\n    console.error(`Subtitle generation failed for ${courseId}/${videoId}:`, error);\n    await updateSubtitleStatus(courseId, videoId, 'error');\n    throw error;\n  }\n});\n\n// Implement processors for each queue\naudioExtractionQueue.process(async (job) => {\n  // Audio extraction implementation\n});\n\ntranscriptionQueue.process(async (job) => {\n  // Transcription implementation\n});\n\n// ... and so on for other queues\n```\n\n4. Implement job retry logic with exponential backoff\n5. Add monitoring and alerting for failed jobs\n6. Implement cleanup of temporary files\n7. Add concurrency control to manage resource usage",
        "testStrategy": "1. Unit test each queue processor\n2. Test job scheduling and execution\n3. Test error handling and retry mechanisms\n4. Test job progress tracking\n5. Test concurrency handling with multiple jobs\n6. Test recovery from Redis failures\n7. Test cleanup of temporary resources\n8. Performance testing with various job sizes\n9. Test monitoring and alerting functionality",
        "priority": "high",
        "dependencies": [
          11,
          13,
          14,
          15,
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Video Player UI Integration",
        "description": "Update the video player UI to support subtitle language selection and display.",
        "details": "Enhance the VdoCipher video player integration to support subtitle selection:\n\n1. Update the video player component to handle subtitle options\n2. Add language selection dropdown in the player controls\n3. Implement subtitle toggle functionality\n\n```javascript\nimport React, { useState, useEffect } from 'react';\nimport { useSupabaseClient } from '@supabase/auth-helpers-react';\n\nconst VideoPlayer = ({ courseId, videoId, playbackId }) => {\n  const [subtitleLanguages, setSubtitleLanguages] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const supabaseClient = useSupabaseClient();\n  \n  useEffect(() => {\n    const loadVideoData = async () => {\n      try {\n        setIsLoading(true);\n        \n        // Get course data to check available subtitle languages\n        const { data: course, error: courseError } = await supabaseClient\n          .from('courses')\n          .select('subtitle_languages')\n          .eq('id', courseId)\n          .single();\n        \n        if (courseError) throw courseError;\n        \n        // Filter available languages\n        const availableLanguages = [];\n        if (course.subtitle_languages) {\n          Object.entries(course.subtitle_languages).forEach(([lang, available]) => {\n            if (available) {\n              availableLanguages.push({\n                code: lang,\n                label: lang === 'fr' ? 'Français' : lang === 'en' ? 'English' : 'Español'\n              });\n            }\n          });\n        }\n        \n        setSubtitleLanguages(availableLanguages);\n      } catch (err) {\n        console.error('Failed to load video data:', err);\n        setError('Failed to load video data');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    \n    loadVideoData();\n  }, [courseId, videoId]);\n  \n  // Initialize VdoCipher player with subtitle options\n  useEffect(() => {\n    if (!isLoading && playbackId) {\n      const playerContainer = document.getElementById('vdo-player');\n      \n      // Clear previous player instance\n      if (playerContainer) {\n        playerContainer.innerHTML = '';\n      }\n      \n      // Initialize player with subtitle options\n      const vdoPlayer = new window.VdoPlayer({\n        otp: '[OTP_PLACEHOLDER]',\n        playbackInfo: playbackId,\n        theme: 'dark',\n        container: playerContainer,\n        preferences: {\n          captions: {\n            enabled: subtitleLanguages.length > 0,\n            language: subtitleLanguages.length > 0 ? subtitleLanguages[0].code : ''\n          }\n        }\n      });\n      \n      // Add event listeners for player\n      vdoPlayer.addEventListener('ready', () => {\n        console.log('Player ready');\n      });\n      \n      return () => {\n        // Cleanup player on unmount\n        if (vdoPlayer) {\n          vdoPlayer.destroy();\n        }\n      };\n    }\n  }, [isLoading, playbackId, subtitleLanguages]);\n  \n  if (isLoading) return <div>Loading video player...</div>;\n  if (error) return <div>Error: {error}</div>;\n  \n  return (\n    <div className=\"video-player-container\">\n      <div id=\"vdo-player\" style={{ width: '100%', aspectRatio: '16/9' }}></div>\n      \n      {subtitleLanguages.length > 0 && (\n        <div className=\"subtitle-controls\">\n          <label htmlFor=\"subtitle-language\">Subtitles:</label>\n          <select \n            id=\"subtitle-language\"\n            onChange={(e) => {\n              // Update player subtitle language\n              const player = window.vdoPlayer;\n              if (player) {\n                if (e.target.value === 'off') {\n                  player.disableSubtitles();\n                } else {\n                  player.enableSubtitles(e.target.value);\n                }\n              }\n            }}\n          >\n            <option value=\"off\">Off</option>\n            {subtitleLanguages.map(lang => (\n              <option key={lang.code} value={lang.code}>\n                {lang.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoPlayer;\n```\n\n4. Add styling for subtitle display\n5. Implement subtitle font size and position controls\n6. Add accessibility features for subtitle display\n7. Ensure responsive design for different screen sizes",
        "testStrategy": "1. Test subtitle loading and display in the player\n2. Test language selection functionality\n3. Verify subtitle synchronization with video\n4. Test subtitle toggle on/off\n5. Test across different browsers and devices\n6. Test accessibility compliance\n7. Test responsive design on various screen sizes\n8. User testing with different language preferences\n9. Test with screen readers and assistive technologies",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Creator UI for Subtitle Management",
        "description": "Implement UI components for course creators to manage subtitle generation and view status.",
        "details": "Create UI components for subtitle management in the course creation interface:\n\n1. Add subtitle generation controls in the video upload workflow\n2. Create a subtitle status dashboard for creators\n3. Implement regeneration controls for failed subtitles\n\n```javascript\nimport React, { useState, useEffect } from 'react';\nimport { useSupabaseClient } from '@supabase/auth-helpers-react';\n\nconst SubtitleManager = ({ courseId, videoId }) => {\n  const [status, setStatus] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [error, setError] = useState(null);\n  const supabaseClient = useSupabaseClient();\n  \n  // Fetch current subtitle status\n  const fetchStatus = async () => {\n    try {\n      setIsLoading(true);\n      const response = await fetch(`/api/upload-video/subtitle-status?courseId=${courseId}&videoId=${videoId}`);\n      \n      if (!response.ok) {\n        throw new Error('Failed to fetch subtitle status');\n      }\n      \n      const data = await response.json();\n      setStatus(data);\n    } catch (err) {\n      console.error('Error fetching subtitle status:', err);\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  // Generate subtitles\n  const generateSubtitles = async () => {\n    try {\n      setIsGenerating(true);\n      setError(null);\n      \n      // Get video URL\n      const { data: video, error: videoError } = await supabaseClient\n        .from('videos')\n        .select('url')\n        .eq('id', videoId)\n        .single();\n      \n      if (videoError) throw videoError;\n      \n      const response = await fetch('/api/upload-video/generate-subtitles', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          courseId,\n          videoId,\n          videoUrl: video.url\n        })\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || 'Failed to generate subtitles');\n      }\n      \n      await fetchStatus();\n    } catch (err) {\n      console.error('Error generating subtitles:', err);\n      setError(err.message);\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  \n  // Poll for status updates when processing\n  useEffect(() => {\n    fetchStatus();\n    \n    let interval;\n    if (status && ['queued', 'processing', 'uploading_to_player'].includes(status.status)) {\n      interval = setInterval(fetchStatus, 5000);\n    }\n    \n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [courseId, videoId, status?.status]);\n  \n  // Render loading state\n  if (isLoading && !status) {\n    return <div className=\"subtitle-manager loading\">Loading subtitle status...</div>;\n  }\n  \n  // Render status and controls\n  return (\n    <div className=\"subtitle-manager\">\n      <h3>Subtitle Management</h3>\n      \n      {error && (\n        <div className=\"error-message\">{error}</div>\n      )}\n      \n      {status ? (\n        <div className=\"status-container\">\n          <div className=\"status-header\">\n            <span className=\"status-label\">Status:</span>\n            <span className={`status-value status-${status.status}`}>\n              {status.status === 'completed' ? 'Completed' :\n               status.status === 'processing' ? 'Processing' :\n               status.status === 'queued' ? 'Queued' :\n               status.status === 'uploading_to_player' ? 'Uploading to Player' :\n               status.status === 'error' ? 'Error' : status.status}\n            </span>\n          </div>\n          \n          {status.progress && (\n            <div className=\"language-progress\">\n              <h4>Language Progress:</h4>\n              <ul>\n                {Object.entries(status.progress).map(([lang, langStatus]) => (\n                  <li key={lang}>\n                    <span className=\"language-name\">\n                      {lang === 'fr' ? 'French' : lang === 'en' ? 'English' : 'Spanish'}:\n                    </span>\n                    <span className={`language-status status-${langStatus}`}>\n                      {langStatus.charAt(0).toUpperCase() + langStatus.slice(1)}\n                    </span>\n                  </li>\n                ))}\n              </ul>\n            </div>\n          )}\n          \n          {(status.status === 'error' || !status.status) && (\n            <button \n              className=\"generate-button\" \n              onClick={generateSubtitles}\n              disabled={isGenerating}\n            >\n              {isGenerating ? 'Generating...' : 'Generate Subtitles'}\n            </button>\n          )}\n          \n          {status.status === 'completed' && (\n            <button \n              className=\"regenerate-button\" \n              onClick={generateSubtitles}\n              disabled={isGenerating}\n            >\n              {isGenerating ? 'Regenerating...' : 'Regenerate Subtitles'}\n            </button>\n          )}\n        </div>\n      ) : (\n        <div className=\"no-subtitles\">\n          <p>No subtitles have been generated for this video yet.</p>\n          <button \n            className=\"generate-button\" \n            onClick={generateSubtitles}\n            disabled={isGenerating}\n          >\n            {isGenerating ? 'Generating...' : 'Generate Subtitles'}\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SubtitleManager;\n```\n\n4. Add notification system for subtitle completion\n5. Create a subtitle preview component\n6. Implement subtitle editing capabilities (optional)\n7. Add analytics for subtitle usage",
        "testStrategy": "1. Test UI rendering with different subtitle statuses\n2. Test subtitle generation flow\n3. Test status polling and updates\n4. Test error handling and display\n5. Test regeneration functionality\n6. Test across different browsers and devices\n7. Test accessibility compliance\n8. User testing with course creators\n9. Test notification system\n10. Test with various network conditions",
        "priority": "low",
        "dependencies": [
          17,
          18
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-09T13:32:08.672Z",
      "updated": "2025-08-11T15:23:27.825Z",
      "description": "Tasks for master context"
    }
  }
}